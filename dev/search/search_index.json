{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Columbo - 0.11.0 columbo provides a way to specify a dynamic set of questions to ask a user and get their answers. columbo 's feature set allows a program to: Ask multiple types of questions: Yes or No Multiple choice Open-ended Validate the response provided by the user. Use answers from earlier questions: As part of the text of a question As part of the text of a default value To decide if a question should be skipped Accept answers from the command line in addition to prompting the user. Example User Prompts The primary use of columbo is to define a sequence of interactions that are used to prompt a user to provide answers using a terminal. Below is a sample which shows some ways this can be used. import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" , ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions ) print ( answers ) Below shows the output when the user accepts the default values for most of the questions. The user provides a different value for the email and explicitly confirms that they like dogs. Welcome to the Columbo example Press enter to start What is your name? [Patrick]: What email address should be used to contact Patrick? [me@example.com]: patrick@example.com How are you feeling today? 1 - happy 2 - sad 3 - sleepy 4 - confused Enter the number of your choice [1]: Do you like dogs? (Y/n): y {'user': 'Patrick', 'user_email': 'patrick@example.com', 'mood': 'happy', 'likes_dogs': True} Command Line Answers In addition to the interactive prompts, columbo can also parse command line arguments for interactions. This is done by changing columbo.get_answers() to columbo.parse_args() . Below shows the output when using the same interactions from above. $ python columbo_example.py --user-email patrick@example.com --likes-dogs { 'user' : 'Patrick' , 'user_email' : 'patrick@example.com' , 'mood' : 'happy' , 'likes_dogs' : True } The full example import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" , ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . parse_args ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-dogs\" , ], ) print ( answers ) Where to Start? To learn the basics of how to start using columbo , read the Getting Started page. Detailed Documentation To learn more about the various ways columbo can be used, read the Usage Guide page. API Reference To find detailed information about a specific function or class, read the API Reference .","title":"Overview"},{"location":"#columbo-0110","text":"columbo provides a way to specify a dynamic set of questions to ask a user and get their answers. columbo 's feature set allows a program to: Ask multiple types of questions: Yes or No Multiple choice Open-ended Validate the response provided by the user. Use answers from earlier questions: As part of the text of a question As part of the text of a default value To decide if a question should be skipped Accept answers from the command line in addition to prompting the user.","title":"Columbo - 0.11.0"},{"location":"#example","text":"","title":"Example"},{"location":"#user-prompts","text":"The primary use of columbo is to define a sequence of interactions that are used to prompt a user to provide answers using a terminal. Below is a sample which shows some ways this can be used. import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" , ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions ) print ( answers ) Below shows the output when the user accepts the default values for most of the questions. The user provides a different value for the email and explicitly confirms that they like dogs. Welcome to the Columbo example Press enter to start What is your name? [Patrick]: What email address should be used to contact Patrick? [me@example.com]: patrick@example.com How are you feeling today? 1 - happy 2 - sad 3 - sleepy 4 - confused Enter the number of your choice [1]: Do you like dogs? (Y/n): y {'user': 'Patrick', 'user_email': 'patrick@example.com', 'mood': 'happy', 'likes_dogs': True}","title":"User Prompts"},{"location":"#command-line-answers","text":"In addition to the interactive prompts, columbo can also parse command line arguments for interactions. This is done by changing columbo.get_answers() to columbo.parse_args() . Below shows the output when using the same interactions from above. $ python columbo_example.py --user-email patrick@example.com --likes-dogs { 'user' : 'Patrick' , 'user_email' : 'patrick@example.com' , 'mood' : 'happy' , 'likes_dogs' : True } The full example import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" , ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . parse_args ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-dogs\" , ], ) print ( answers )","title":"Command Line Answers"},{"location":"#where-to-start","text":"To learn the basics of how to start using columbo , read the Getting Started page.","title":"Where to Start?"},{"location":"#detailed-documentation","text":"To learn more about the various ways columbo can be used, read the Usage Guide page.","title":"Detailed Documentation"},{"location":"#api-reference","text":"To find detailed information about a specific function or class, read the API Reference .","title":"API Reference"},{"location":"api/","text":"Reference Type Aliases columbo uses type aliases heavily to simplify the annotations for the functions provided by the library. The following table defines the aliases that are used. Alias Value Answer Union[bool, str] Answers Mapping[str, Answer] Interaction Union[Echo, Acknowledge, Question] MutableAnswers MutableMapping[str, Answer] OptionList List[str] Possible * Union[T, Literal[_Sentinel]] ShouldAsk Callable[[Answers], bool] StaticOrDynamicValue Union[V, Callable[[Answers], V]] ValidationResponse Union[ValidationSuccess, ValidationFailure] Validator Callable[[str, Answers], ValidationResponse] Note Possible is a special construct used in copy() methods to indicate that a value was not provided. Possible & _Sentinel are not exposed by columbo , but are documented here for completeness. Interactions Acknowledge Display a message to the user and require the user to press ENTER to continue. __init__ ( self , message ) special Initialize an instance. Parameters: Name Type Description Default message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required copy ( self , * , message =< _Sentinel . A : 0 > ) Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> Returns: Type Description Acknowledge A newly constructed instance with the given values in place of the values of this instance. BasicQuestion ( Question ) A question with an arbitrary text answer. __init__ ( self , name , message , default , cli_help = None , should_ask = None , validator = None , value_if_not_asked = None ) special Initialize an instance. Parameters: Name Type Description Default name str The identifier that will be used as the key to access the this question's answer. required message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required default Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. required cli_help Optional[str] Optional help message to be displayed for command line interface. None should_ask Optional[Callable[[Mapping[str, Union[bool, str]]], bool]] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. None validator Optional[Callable[[str, Mapping[str, Union[bool, str]]], Union[columbo._types.ValidationSuccess, columbo._types.ValidationFailure]]] Callable that will validate the response given by the user. A ValidationSuccess object indicates success and a ValidationFailure object indicates failure. None value_if_not_asked Optional[str] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. None ask ( self , answers , no_user_input = False ) Prompt the user with this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description str The answer to the question. copy ( self , * , name =< _Sentinel . A : 0 > , message =< _Sentinel . A : 0 > , default =< _Sentinel . A : 0 > , cli_help =< _Sentinel . A : 0 > , should_ask =< _Sentinel . A : 0 > , validator =< _Sentinel . A : 0 > , value_if_not_asked =< _Sentinel . A : 0 > ) Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default name Union[str, columbo._interaction._Sentinel] The identifier that will be used as the key to access the this question's answer. <_Sentinel.A: 0> message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> default Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> cli_help Union[str, NoneType, columbo._interaction._Sentinel] Optional help message to be displayed for command line interface. <_Sentinel.A: 0> should_ask Union[Callable[[Mapping[str, Union[bool, str]]], bool], NoneType, columbo._interaction._Sentinel] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. <_Sentinel.A: 0> validator Union[Callable[[str, Mapping[str, Union[bool, str]]], Union[columbo._types.ValidationSuccess, columbo._types.ValidationFailure]], NoneType, columbo._interaction._Sentinel] Callable that will validate the response given by the user. None indicates that validation was successful. Otherwise, a string containing details of the error that caused the validation failure. <_Sentinel.A: 0> value_if_not_asked Union[str, NoneType, columbo._interaction._Sentinel] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. <_Sentinel.A: 0> Returns: Type Description BasicQuestion A newly constructed instance with the given values in place of the values of this instance. validate ( self , value , answers ) Validate the value (a new answer). Parameters: Name Type Description Default value str The identifier that will be used as the key to access the this question's answer. required answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required Returns: Type Description Union[columbo._types.ValidationSuccess, columbo._types.ValidationFailure] A ValidationFailure or ValidationSuccess object. Choice ( Question ) A question with a set of possible answers. __init__ ( self , name , message , options , default , cli_help = None , should_ask = None , value_if_not_asked = None ) special Initialize an instance. Parameters: Name Type Description Default name str The identifier that will be used as the key to access the this question's answer. required message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required options Union[List[str], Callable[[Mapping[str, Union[bool, str]]], List[str]]] The set of possible answers to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. required default Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. required cli_help Optional[str] Optional help message to be displayed for command line interface. None should_ask Optional[Callable[[Mapping[str, Union[bool, str]]], bool]] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. None value_if_not_asked Optional[str] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. None Exceptions: Type Description ValueError Raised if the value_if_not_asked is not one of the options. ask ( self , answers , no_user_input = False ) Prompt the user with this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description str The answer to the question. copy ( self , * , name =< _Sentinel . A : 0 > , message =< _Sentinel . A : 0 > , options =< _Sentinel . A : 0 > , default =< _Sentinel . A : 0 > , cli_help =< _Sentinel . A : 0 > , should_ask =< _Sentinel . A : 0 > , value_if_not_asked =< _Sentinel . A : 0 > ) Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default name Union[str, columbo._interaction._Sentinel] The identifier that will be used as the key to access the this question's answer. <_Sentinel.A: 0> message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> options Union[List[str], Callable[[Mapping[str, Union[bool, str]]], List[str]], columbo._interaction._Sentinel] The set of possible answers to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> default Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> cli_help Union[str, NoneType, columbo._interaction._Sentinel] Optional help message to be displayed for command line interface. <_Sentinel.A: 0> should_ask Union[Callable[[Mapping[str, Union[bool, str]]], bool], NoneType, columbo._interaction._Sentinel] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. <_Sentinel.A: 0> value_if_not_asked Union[str, NoneType, columbo._interaction._Sentinel] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. <_Sentinel.A: 0> Returns: Type Description Choice A newly constructed instance with the given values in place of the values of this instance. validate ( self , value , answers ) Validate the value (a new answer). Parameters: Name Type Description Default value str The identifier that will be used as the key to access the this question's answer. required answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required Returns: Type Description Union[columbo._types.ValidationSuccess, columbo._types.ValidationFailure] A ValidationFailure or ValidationSuccess object. Confirm ( Question ) A question with a yes or no answer. __init__ ( self , name , message , default = False , cli_help = None , should_ask = None , value_if_not_asked = None ) special Initialize an instance. Parameters: Name Type Description Default name str The identifier that will be used as the key to access the this question's answer. required message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required default Union[bool, Callable[[Mapping[str, Union[bool, str]]], bool]] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. False cli_help Optional[str] Optional help message to be displayed for command line interface. None should_ask Optional[Callable[[Mapping[str, Union[bool, str]]], bool]] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. None value_if_not_asked Optional[bool] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. None ask ( self , answers , no_user_input = False ) Prompt the user with this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description bool The answer to the question. copy ( self , * , name =< _Sentinel . A : 0 > , message =< _Sentinel . A : 0 > , default =< _Sentinel . A : 0 > , cli_help =< _Sentinel . A : 0 > , should_ask =< _Sentinel . A : 0 > , value_if_not_asked =< _Sentinel . A : 0 > ) Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default name Union[str, columbo._interaction._Sentinel] The identifier that will be used as the key to access the this question's answer. <_Sentinel.A: 0> message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> default Union[bool, Callable[[Mapping[str, Union[bool, str]]], bool], columbo._interaction._Sentinel] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> cli_help Union[str, NoneType, columbo._interaction._Sentinel] Optional help message to be displayed for command line interface. <_Sentinel.A: 0> should_ask Union[Callable[[Mapping[str, Union[bool, str]]], bool], NoneType, columbo._interaction._Sentinel] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. <_Sentinel.A: 0> value_if_not_asked Union[bool, NoneType, columbo._interaction._Sentinel] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. <_Sentinel.A: 0> Returns: Type Description Confirm A newly constructed instance with the given values in place of the values of this instance. Echo Display a message to the user. __init__ ( self , message ) special Initialize an instance. Parameters: Name Type Description Default message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required copy ( self , * , message =< _Sentinel . A : 0 > ) Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> Returns: Type Description Echo A newly constructed instance with the given values in place of the values of this instance. Question ( ABC ) Base class for a prompt to the user that produces an answer. __init__ ( self , name , message , cli_help = None , should_ask = None , value_if_not_asked = None ) special Initialize an instance. Parameters: Name Type Description Default name str The identifier that will be used as the key to access the this question's answer. required message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required cli_help Optional[str] Optional help message to be displayed for command line interface. None should_ask Optional[Callable[[Mapping[str, Union[bool, str]]], bool]] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. None value_if_not_asked Union[str, bool] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. None Exceptions: Type Description ValueError Raised if user provides a value_if_not_asked but nothing for should_ask. ask ( self , answers , no_user_input = False ) Prompt the user with this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description Union[bool, str] The answer to the question. should_ask ( self , answers ) Should the user be asked this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required Returns: Type Description bool True if this questions should be asked Functions format_cli_help ( interactions , parser_name = None ) Produce CLI help text for a given set of interactions. Parameters: Name Type Description Default interactions Collection[Union[Echo, Acknowledge, Question]] Interactions that should be turned into CLI arguments. required parser_name Optional[str] Optional name to be used in help text. If omitted, the name of the process will be used. None Exceptions: Type Description DuplicateQuestionNameException One of the given questions attempts to reuse a name. get_answers ( interactions , answers = None , no_user_input = False ) Iterates over collection of interactions, invoking interaction specific behavior. Parameters: Name Type Description Default interactions Collection[Union[Echo, Acknowledge, Question]] Collection of interactions to present the user with. required answers Optional[Mapping[str, Union[bool, str]]] An initial dictionary of answers to start from. None no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description MutableMapping[str, Union[bool, str]] Dictionary of answers. Exceptions: Type Description DuplicateQuestionNameException One of the given questions attempts to reuse a name. This includes a question that was used to create answers if given. parse_args ( interactions , args = None , exit_on_error = True , answers = None , parser_name = None ) Parse command line argument for the given interactions. Parameters: Name Type Description Default interactions Collection[Union[Echo, Acknowledge, Question]] Interactions that should be turned into CLI arguments. required args Optional[Sequence[str]] Arguments to parse. If None , sys.argv will be used. None exit_on_error bool If True , print the CLI usage and exit the application. Otherwise, raise an exception with the error information. True answers Optional[Mapping[str, Union[bool, str]]] An initial dictionary of answers to start from. None parser_name Optional[str] Optional name to be used in error text. If omitted, the name of the process will be used. None Returns: Type Description MutableMapping[str, Union[bool, str]] Answers based on the given arguments. Exceptions: Type Description SystemExit A value passed to CLI argument was not valid and exit_on_error was True . CliException A value passed to CLI argument was not valid and exit_on_error was False . DuplicateQuestionNameException One of the given questions attempts to reuse a name. This includes a question that was used to create answers if given. Exceptions CliException ( ColumboException ) An error occurred while processing command line arguments. ColumboException ( Exception ) Base exception for exceptions raised by Columbo DuplicateQuestionNameException ( ColumboException ) Multiple questions use the same name.","title":"Reference"},{"location":"api/#reference","text":"","title":"Reference"},{"location":"api/#type-aliases","text":"columbo uses type aliases heavily to simplify the annotations for the functions provided by the library. The following table defines the aliases that are used. Alias Value Answer Union[bool, str] Answers Mapping[str, Answer] Interaction Union[Echo, Acknowledge, Question] MutableAnswers MutableMapping[str, Answer] OptionList List[str] Possible * Union[T, Literal[_Sentinel]] ShouldAsk Callable[[Answers], bool] StaticOrDynamicValue Union[V, Callable[[Answers], V]] ValidationResponse Union[ValidationSuccess, ValidationFailure] Validator Callable[[str, Answers], ValidationResponse] Note Possible is a special construct used in copy() methods to indicate that a value was not provided. Possible & _Sentinel are not exposed by columbo , but are documented here for completeness.","title":"Type Aliases"},{"location":"api/#interactions","text":"","title":"Interactions"},{"location":"api/#columbo._interaction.Acknowledge","text":"Display a message to the user and require the user to press ENTER to continue.","title":"Acknowledge"},{"location":"api/#columbo._interaction.Acknowledge.__init__","text":"Initialize an instance. Parameters: Name Type Description Default message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required","title":"__init__()"},{"location":"api/#columbo._interaction.Acknowledge.copy","text":"Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> Returns: Type Description Acknowledge A newly constructed instance with the given values in place of the values of this instance.","title":"copy()"},{"location":"api/#columbo._interaction.BasicQuestion","text":"A question with an arbitrary text answer.","title":"BasicQuestion"},{"location":"api/#columbo._interaction.BasicQuestion.__init__","text":"Initialize an instance. Parameters: Name Type Description Default name str The identifier that will be used as the key to access the this question's answer. required message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required default Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. required cli_help Optional[str] Optional help message to be displayed for command line interface. None should_ask Optional[Callable[[Mapping[str, Union[bool, str]]], bool]] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. None validator Optional[Callable[[str, Mapping[str, Union[bool, str]]], Union[columbo._types.ValidationSuccess, columbo._types.ValidationFailure]]] Callable that will validate the response given by the user. A ValidationSuccess object indicates success and a ValidationFailure object indicates failure. None value_if_not_asked Optional[str] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. None","title":"__init__()"},{"location":"api/#columbo._interaction.BasicQuestion.ask","text":"Prompt the user with this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description str The answer to the question.","title":"ask()"},{"location":"api/#columbo._interaction.BasicQuestion.copy","text":"Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default name Union[str, columbo._interaction._Sentinel] The identifier that will be used as the key to access the this question's answer. <_Sentinel.A: 0> message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> default Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> cli_help Union[str, NoneType, columbo._interaction._Sentinel] Optional help message to be displayed for command line interface. <_Sentinel.A: 0> should_ask Union[Callable[[Mapping[str, Union[bool, str]]], bool], NoneType, columbo._interaction._Sentinel] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. <_Sentinel.A: 0> validator Union[Callable[[str, Mapping[str, Union[bool, str]]], Union[columbo._types.ValidationSuccess, columbo._types.ValidationFailure]], NoneType, columbo._interaction._Sentinel] Callable that will validate the response given by the user. None indicates that validation was successful. Otherwise, a string containing details of the error that caused the validation failure. <_Sentinel.A: 0> value_if_not_asked Union[str, NoneType, columbo._interaction._Sentinel] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. <_Sentinel.A: 0> Returns: Type Description BasicQuestion A newly constructed instance with the given values in place of the values of this instance.","title":"copy()"},{"location":"api/#columbo._interaction.BasicQuestion.validate","text":"Validate the value (a new answer). Parameters: Name Type Description Default value str The identifier that will be used as the key to access the this question's answer. required answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required Returns: Type Description Union[columbo._types.ValidationSuccess, columbo._types.ValidationFailure] A ValidationFailure or ValidationSuccess object.","title":"validate()"},{"location":"api/#columbo._interaction.Choice","text":"A question with a set of possible answers.","title":"Choice"},{"location":"api/#columbo._interaction.Choice.__init__","text":"Initialize an instance. Parameters: Name Type Description Default name str The identifier that will be used as the key to access the this question's answer. required message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required options Union[List[str], Callable[[Mapping[str, Union[bool, str]]], List[str]]] The set of possible answers to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. required default Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. required cli_help Optional[str] Optional help message to be displayed for command line interface. None should_ask Optional[Callable[[Mapping[str, Union[bool, str]]], bool]] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. None value_if_not_asked Optional[str] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. None Exceptions: Type Description ValueError Raised if the value_if_not_asked is not one of the options.","title":"__init__()"},{"location":"api/#columbo._interaction.Choice.ask","text":"Prompt the user with this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description str The answer to the question.","title":"ask()"},{"location":"api/#columbo._interaction.Choice.copy","text":"Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default name Union[str, columbo._interaction._Sentinel] The identifier that will be used as the key to access the this question's answer. <_Sentinel.A: 0> message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> options Union[List[str], Callable[[Mapping[str, Union[bool, str]]], List[str]], columbo._interaction._Sentinel] The set of possible answers to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> default Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> cli_help Union[str, NoneType, columbo._interaction._Sentinel] Optional help message to be displayed for command line interface. <_Sentinel.A: 0> should_ask Union[Callable[[Mapping[str, Union[bool, str]]], bool], NoneType, columbo._interaction._Sentinel] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. <_Sentinel.A: 0> value_if_not_asked Union[str, NoneType, columbo._interaction._Sentinel] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. <_Sentinel.A: 0> Returns: Type Description Choice A newly constructed instance with the given values in place of the values of this instance.","title":"copy()"},{"location":"api/#columbo._interaction.Choice.validate","text":"Validate the value (a new answer). Parameters: Name Type Description Default value str The identifier that will be used as the key to access the this question's answer. required answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required Returns: Type Description Union[columbo._types.ValidationSuccess, columbo._types.ValidationFailure] A ValidationFailure or ValidationSuccess object.","title":"validate()"},{"location":"api/#columbo._interaction.Confirm","text":"A question with a yes or no answer.","title":"Confirm"},{"location":"api/#columbo._interaction.Confirm.__init__","text":"Initialize an instance. Parameters: Name Type Description Default name str The identifier that will be used as the key to access the this question's answer. required message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required default Union[bool, Callable[[Mapping[str, Union[bool, str]]], bool]] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. False cli_help Optional[str] Optional help message to be displayed for command line interface. None should_ask Optional[Callable[[Mapping[str, Union[bool, str]]], bool]] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. None value_if_not_asked Optional[bool] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. None","title":"__init__()"},{"location":"api/#columbo._interaction.Confirm.ask","text":"Prompt the user with this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description bool The answer to the question.","title":"ask()"},{"location":"api/#columbo._interaction.Confirm.copy","text":"Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default name Union[str, columbo._interaction._Sentinel] The identifier that will be used as the key to access the this question's answer. <_Sentinel.A: 0> message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> default Union[bool, Callable[[Mapping[str, Union[bool, str]]], bool], columbo._interaction._Sentinel] The default answer to the question. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> cli_help Union[str, NoneType, columbo._interaction._Sentinel] Optional help message to be displayed for command line interface. <_Sentinel.A: 0> should_ask Union[Callable[[Mapping[str, Union[bool, str]]], bool], NoneType, columbo._interaction._Sentinel] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. <_Sentinel.A: 0> value_if_not_asked Union[bool, NoneType, columbo._interaction._Sentinel] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. <_Sentinel.A: 0> Returns: Type Description Confirm A newly constructed instance with the given values in place of the values of this instance.","title":"copy()"},{"location":"api/#columbo._interaction.Echo","text":"Display a message to the user.","title":"Echo"},{"location":"api/#columbo._interaction.Echo.__init__","text":"Initialize an instance. Parameters: Name Type Description Default message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required","title":"__init__()"},{"location":"api/#columbo._interaction.Echo.copy","text":"Create a new instance like this one, potentially with different values. Parameters: Name Type Description Default message Union[str, Callable[[Mapping[str, Union[bool, str]]], str], columbo._interaction._Sentinel] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. <_Sentinel.A: 0> Returns: Type Description Echo A newly constructed instance with the given values in place of the values of this instance.","title":"copy()"},{"location":"api/#columbo._interaction.Question","text":"Base class for a prompt to the user that produces an answer.","title":"Question"},{"location":"api/#columbo._interaction.Question.__init__","text":"Initialize an instance. Parameters: Name Type Description Default name str The identifier that will be used as the key to access the this question's answer. required message Union[str, Callable[[Mapping[str, Union[bool, str]]], str]] The message to be displayed to the user. If the value is callable, the argument passed in will be the answers that have been provided this far. required cli_help Optional[str] Optional help message to be displayed for command line interface. None should_ask Optional[Callable[[Mapping[str, Union[bool, str]]], bool]] If None , the question is asked. Otherwise, the callable will be passed the answers that have been provided this far and should return True if the question should be asked. None value_if_not_asked Union[str, bool] If provided and if should_ask is being used, this value will be recorded as an answer if should_ask evaluates to False. None Exceptions: Type Description ValueError Raised if user provides a value_if_not_asked but nothing for should_ask.","title":"__init__()"},{"location":"api/#columbo._interaction.Question.ask","text":"Prompt the user with this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description Union[bool, str] The answer to the question.","title":"ask()"},{"location":"api/#columbo._interaction.Question.should_ask","text":"Should the user be asked this question. Parameters: Name Type Description Default answers Mapping[str, Union[bool, str]] The answers that have been provided this far. required Returns: Type Description bool True if this questions should be asked","title":"should_ask()"},{"location":"api/#functions","text":"","title":"Functions"},{"location":"api/#columbo._cli.format_cli_help","text":"Produce CLI help text for a given set of interactions. Parameters: Name Type Description Default interactions Collection[Union[Echo, Acknowledge, Question]] Interactions that should be turned into CLI arguments. required parser_name Optional[str] Optional name to be used in help text. If omitted, the name of the process will be used. None Exceptions: Type Description DuplicateQuestionNameException One of the given questions attempts to reuse a name.","title":"format_cli_help()"},{"location":"api/#columbo._interaction.get_answers","text":"Iterates over collection of interactions, invoking interaction specific behavior. Parameters: Name Type Description Default interactions Collection[Union[Echo, Acknowledge, Question]] Collection of interactions to present the user with. required answers Optional[Mapping[str, Union[bool, str]]] An initial dictionary of answers to start from. None no_user_input bool If True the default value for the question will be used without waiting for the user to provide an answer. Default: False False Returns: Type Description MutableMapping[str, Union[bool, str]] Dictionary of answers. Exceptions: Type Description DuplicateQuestionNameException One of the given questions attempts to reuse a name. This includes a question that was used to create answers if given.","title":"get_answers()"},{"location":"api/#columbo._cli.parse_args","text":"Parse command line argument for the given interactions. Parameters: Name Type Description Default interactions Collection[Union[Echo, Acknowledge, Question]] Interactions that should be turned into CLI arguments. required args Optional[Sequence[str]] Arguments to parse. If None , sys.argv will be used. None exit_on_error bool If True , print the CLI usage and exit the application. Otherwise, raise an exception with the error information. True answers Optional[Mapping[str, Union[bool, str]]] An initial dictionary of answers to start from. None parser_name Optional[str] Optional name to be used in error text. If omitted, the name of the process will be used. None Returns: Type Description MutableMapping[str, Union[bool, str]] Answers based on the given arguments. Exceptions: Type Description SystemExit A value passed to CLI argument was not valid and exit_on_error was True . CliException A value passed to CLI argument was not valid and exit_on_error was False . DuplicateQuestionNameException One of the given questions attempts to reuse a name. This includes a question that was used to create answers if given.","title":"parse_args()"},{"location":"api/#exceptions","text":"","title":"Exceptions"},{"location":"api/#columbo._exception.CliException","text":"An error occurred while processing command line arguments.","title":"CliException"},{"location":"api/#columbo._exception.ColumboException","text":"Base exception for exceptions raised by Columbo","title":"ColumboException"},{"location":"api/#columbo._exception.DuplicateQuestionNameException","text":"Multiple questions use the same name.","title":"DuplicateQuestionNameException"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [Unreleased] Added Python version 3.10 tested during CI Python version 3.10 added to package classifiers Removed Support for Python version 3.6 . [0.11.0] - 2021-08-04 Changed Removed legacy validator signature and logic Added value_if_not_asked kwarg for Question interactions to set a value if the question is not asked ( #169 ) [0.10.1] - 2021-02-26 Fixed dataclasses was not listed as a dependency for versions of Python < 3.7 [0.10.0] - 2021-02-18 Added Python 3.9 support ( #73 ) New Validator signature ( #37 ) Changed Improved validation for converting question names to command line arguments ( #82 ) Deprecated Support for Validator s that return Optional[str] ( #39 ) [0.9.0] - 2020-12-18 First public release. No code changes from v0.8.0. [0.8.0] - 2020-02-17 Added All Interaction s gained a copy() method to allow for creating slightly altered instances of an existing Interaction . parse_args() and format_cli_help() accept an optional parser_name to be displayed in errors and help text. Changed Stop producing universal wheels. Fixed StaticOrDynamicValue enforces that the result of the callable must be the same type as the static type. Removed DynamicValue is no longer exposed as a type alias. [0.7.0] - 2020-02-10 Added format_cli_help() function to produce CLI help text. Changed Type hints on public API. Be more restrictive when functions should not be making mutations. Be less restrictive when functions don't rely on specific implementations. Fixed CliException inherits from ColumboException . Raise DuplicateQuestionNameException if a list of interactions contains multiple questions with the same name. The same exception is also raised when an existing answers dictionary already contains a name used by a given questions. [0.6.0] - 2020-01-13 Added parse_args() function now accepts an initial dictionary of answers . Fixed Expose additional type hints used in signatures of public API. [0.5.0] - 2020-01-06 Added exit_on_error added to parse_args() as an optional argument. When False , the function will raise an exception instead of exiting the application if the arguments can't be parsed. Changed Rewrote Columbo example script text. Made example script stand alone. Test against each supported python version in CI. Add support for python 3.8. Use prompt-toolkit for user interaction instead of click . Mark user_io sub-module as private. Expose exception types raised by library. Fixed Add Args class that user_io relies on. Explicit type is required for singledispatch on python 3.6. Specify minimum supported python version. Removed Ability to run the module as an application. Dynamic loading of questions from a file. [0.4.0] - 2019-12-17 Changed return type of Validator return type updated from bool to Optional[str] is_valid function updated to validate , return type updated from bool to Optional[str] Fixed BasicQuestion constructor now respects the validator argument If validator callable provided, question will be asked until validator returns True [0.3.0] - 2019-11-21 get_answers() takes optional answers dict, appending new answers to this as opposed to new dictionary [0.2.0] - 2019-11-08 Added get_answers() takes list of interactions and builds dict of answers, handling user I/O [0.1.0] - 2019-10-15 Initial Release","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#added","text":"Python version 3.10 tested during CI Python version 3.10 added to package classifiers","title":"Added"},{"location":"changelog/#removed","text":"Support for Python version 3.6 .","title":"Removed"},{"location":"changelog/#0110-2021-08-04","text":"","title":"[0.11.0] - 2021-08-04"},{"location":"changelog/#changed","text":"Removed legacy validator signature and logic","title":"Changed"},{"location":"changelog/#added_1","text":"value_if_not_asked kwarg for Question interactions to set a value if the question is not asked ( #169 )","title":"Added"},{"location":"changelog/#0101-2021-02-26","text":"","title":"[0.10.1] - 2021-02-26"},{"location":"changelog/#fixed","text":"dataclasses was not listed as a dependency for versions of Python < 3.7","title":"Fixed"},{"location":"changelog/#0100-2021-02-18","text":"","title":"[0.10.0] - 2021-02-18"},{"location":"changelog/#added_2","text":"Python 3.9 support ( #73 ) New Validator signature ( #37 )","title":"Added"},{"location":"changelog/#changed_1","text":"Improved validation for converting question names to command line arguments ( #82 )","title":"Changed"},{"location":"changelog/#deprecated","text":"Support for Validator s that return Optional[str] ( #39 )","title":"Deprecated"},{"location":"changelog/#090-2020-12-18","text":"First public release. No code changes from v0.8.0.","title":"[0.9.0] - 2020-12-18"},{"location":"changelog/#080-2020-02-17","text":"","title":"[0.8.0] - 2020-02-17"},{"location":"changelog/#added_3","text":"All Interaction s gained a copy() method to allow for creating slightly altered instances of an existing Interaction . parse_args() and format_cli_help() accept an optional parser_name to be displayed in errors and help text.","title":"Added"},{"location":"changelog/#changed_2","text":"Stop producing universal wheels.","title":"Changed"},{"location":"changelog/#fixed_1","text":"StaticOrDynamicValue enforces that the result of the callable must be the same type as the static type.","title":"Fixed"},{"location":"changelog/#removed_1","text":"DynamicValue is no longer exposed as a type alias.","title":"Removed"},{"location":"changelog/#070-2020-02-10","text":"","title":"[0.7.0] - 2020-02-10"},{"location":"changelog/#added_4","text":"format_cli_help() function to produce CLI help text.","title":"Added"},{"location":"changelog/#changed_3","text":"Type hints on public API. Be more restrictive when functions should not be making mutations. Be less restrictive when functions don't rely on specific implementations.","title":"Changed"},{"location":"changelog/#fixed_2","text":"CliException inherits from ColumboException . Raise DuplicateQuestionNameException if a list of interactions contains multiple questions with the same name. The same exception is also raised when an existing answers dictionary already contains a name used by a given questions.","title":"Fixed"},{"location":"changelog/#060-2020-01-13","text":"","title":"[0.6.0] - 2020-01-13"},{"location":"changelog/#added_5","text":"parse_args() function now accepts an initial dictionary of answers .","title":"Added"},{"location":"changelog/#fixed_3","text":"Expose additional type hints used in signatures of public API.","title":"Fixed"},{"location":"changelog/#050-2020-01-06","text":"","title":"[0.5.0] - 2020-01-06"},{"location":"changelog/#added_6","text":"exit_on_error added to parse_args() as an optional argument. When False , the function will raise an exception instead of exiting the application if the arguments can't be parsed.","title":"Added"},{"location":"changelog/#changed_4","text":"Rewrote Columbo example script text. Made example script stand alone. Test against each supported python version in CI. Add support for python 3.8. Use prompt-toolkit for user interaction instead of click . Mark user_io sub-module as private. Expose exception types raised by library.","title":"Changed"},{"location":"changelog/#fixed_4","text":"Add Args class that user_io relies on. Explicit type is required for singledispatch on python 3.6. Specify minimum supported python version.","title":"Fixed"},{"location":"changelog/#removed_2","text":"Ability to run the module as an application. Dynamic loading of questions from a file.","title":"Removed"},{"location":"changelog/#040-2019-12-17","text":"","title":"[0.4.0] - 2019-12-17"},{"location":"changelog/#changed_5","text":"return type of Validator return type updated from bool to Optional[str] is_valid function updated to validate , return type updated from bool to Optional[str]","title":"Changed"},{"location":"changelog/#fixed_5","text":"BasicQuestion constructor now respects the validator argument If validator callable provided, question will be asked until validator returns True","title":"Fixed"},{"location":"changelog/#030-2019-11-21","text":"get_answers() takes optional answers dict, appending new answers to this as opposed to new dictionary","title":"[0.3.0] - 2019-11-21"},{"location":"changelog/#020-2019-11-08","text":"","title":"[0.2.0] - 2019-11-08"},{"location":"changelog/#added_7","text":"get_answers() takes list of interactions and builds dict of answers, handling user I/O","title":"Added"},{"location":"changelog/#010-2019-10-15","text":"Initial Release","title":"[0.1.0] - 2019-10-15"},{"location":"development-guide/","text":"Development Guide Welcome! Thank you for wanting to make the project better. This section provides an overview of repository structure and how to work with the code base. Before you dive into this, it is best to read: The whole Usage Guide The Code of Conduct The Contributing guide Docker The Columbo project uses Docker to ease setting up a consistent development environment. The Docker documentation has details on how to install docker on your computer. Once that is configured, the test suite can be run locally: docker-compose run --rm test If you want to be able to execute code in the container: docker-compose run --rm devbox ( your code here ) In the devbox environment you'll be able to enter a python shell and import columbo or any dependencies. Debugging The docker container has pdb++ install that can be used as a debugger. (However, you are welcome to set up a different debugger if you would like.) This allows you to easily create a breakpoint anywhere in the code. def my_function (): breakpoint () ... When your the code, you will drop into an interactive pdb++ debugger. See the documentation on pdb and pdb++ for more information. Testing You'll be unable to merge code unless the linting and tests pass. You can run these in your container via: docker-compose run --rm test This will run the same tests, linting, and code coverage that are run by the CI pipeline. The only difference is that, when run locally, black and isort are configured to automatically correct issues they detect. Generally we should endeavor to write tests for every feature. Every new feature branch should increase the test coverage rather than decreasing it. We use pytest as our testing framework. Stages To customize / override a specific testing stage, please read the documentation specific to that tool: PyTest MyPy Black Isort Flake8 Bandit Validate Examples Used in Documentation In the docs/examples/ directory of this repo, there are example Python scripts which we use in our documentation. You can validate that the examples run properly using: docker-compose run --rm validateDocExamples If the script fails (exits with a non-zero status), it will output information about the file that we need to fix. Note that this script will output some content in the shell every time it runs. Just because the script outputs content to the shell does not mean it has failed; as long as the script finishes successfully (exits with a zero status), there are no problems we need to address. Building the Library columbo is PEP 517 compliant. build is used as the frontend tool for building the library. Setuptools is used as the build backend. setup.cfg contains the library metadata. A setup.py is also included to support an editable install. Requirements requirements.txt - Lists all direct dependencies (packages imported by the library). requirements-test.txt - Lists all direct dependencies needed for development. This primarily covers dependencies needed to run the test suite & lints. Publishing a New Version Once the package is ready to be released, there are a few things that need to be done: Start with a local clone of the repo on the default branch with a clean working tree. Run the version bump script with the appropriate part name ( major , minor , or patch ). Example: docker-compose run --rm bump minor This wil create a new branch, updates all affected files with the new version, and commit the changes to the branch. Push the new branch to create a new pull request. Get the pull request approved. Merge the pull request to the default branch. Merging the pull request will trigger a GitHub Action that will create a new release. The creation of this new release will trigger a GitHub Action that will to build a wheel & a source distributions of the package and push them to PyPI . Warning The action that uploads the files to PyPI will not run until a repository maintainer acknowledges that the job is ready to run. This is to keep the PyPI publishing token secure. Otherwise, any job would have access to the token. In addition to uploading the files to PyPI, the documentation website will be updated to include the new version. If the new version is a full release, it will be made the new latest version. Continuous Integration Pipeline The Continuous Integration (CI) Pipeline runs to confirm that the repository is in a good state. It will run when someone creates a pull request or when they push new commits to the branch for an existing pull request. The pipeline runs multiple different jobs that helps verify the state of the code. This same pipeline also runs on the default branch when a maintainer merges a pull request. Lints The first set of jobs that run as part of the CI pipline are linters that perform static analysis on the code. This includes: MyPy , Black , Isort , Flake8 , and Bandit . Tests The next set of jobs run the unit tests using PyTest . The pipeline runs the tests cases across each supported version of Python to ensure compatibility. For each run of the test cases, the job will record the test results and code coverage information. The pipeline uploads the code coverage information to CodeCov to ensure that a pull request doesn't significantly reduce the total code coverage percentage or introduce a large amount of code that is untested. Distribution Verification The next set of jobs build the wheel distribution, installs in into a virtual environment, and then runs Python to import the library version. This works as a smoke test to ensure that the library can be packaged correctly and used. The pipeline runs the tests cases across each supported version of Python to ensure compatibility. Documentation The remaining jobs are all related to documentation. A job runs each of the code examples that are used in the documentation to verify they produce the expected results. A job builds the documentation in strict mode so that it will fail if there are any errors. The job records the generated files so that the documentation website can be viewed in its rendered form. When the pipeline is running as a result of a maintainer merging a pull request to the default branch, a job runs that publishes the current state of the documentation to as the dev version. This will allow users to view the state of the documentation as it has changed since a maintainer published the latest version.","title":"Development Guide"},{"location":"development-guide/#development-guide","text":"Welcome! Thank you for wanting to make the project better. This section provides an overview of repository structure and how to work with the code base. Before you dive into this, it is best to read: The whole Usage Guide The Code of Conduct The Contributing guide","title":"Development Guide"},{"location":"development-guide/#docker","text":"The Columbo project uses Docker to ease setting up a consistent development environment. The Docker documentation has details on how to install docker on your computer. Once that is configured, the test suite can be run locally: docker-compose run --rm test If you want to be able to execute code in the container: docker-compose run --rm devbox ( your code here ) In the devbox environment you'll be able to enter a python shell and import columbo or any dependencies.","title":"Docker"},{"location":"development-guide/#debugging","text":"The docker container has pdb++ install that can be used as a debugger. (However, you are welcome to set up a different debugger if you would like.) This allows you to easily create a breakpoint anywhere in the code. def my_function (): breakpoint () ... When your the code, you will drop into an interactive pdb++ debugger. See the documentation on pdb and pdb++ for more information.","title":"Debugging"},{"location":"development-guide/#testing","text":"You'll be unable to merge code unless the linting and tests pass. You can run these in your container via: docker-compose run --rm test This will run the same tests, linting, and code coverage that are run by the CI pipeline. The only difference is that, when run locally, black and isort are configured to automatically correct issues they detect. Generally we should endeavor to write tests for every feature. Every new feature branch should increase the test coverage rather than decreasing it. We use pytest as our testing framework.","title":"Testing"},{"location":"development-guide/#stages","text":"To customize / override a specific testing stage, please read the documentation specific to that tool: PyTest MyPy Black Isort Flake8 Bandit","title":"Stages"},{"location":"development-guide/#validate-examples-used-in-documentation","text":"In the docs/examples/ directory of this repo, there are example Python scripts which we use in our documentation. You can validate that the examples run properly using: docker-compose run --rm validateDocExamples If the script fails (exits with a non-zero status), it will output information about the file that we need to fix. Note that this script will output some content in the shell every time it runs. Just because the script outputs content to the shell does not mean it has failed; as long as the script finishes successfully (exits with a zero status), there are no problems we need to address.","title":"Validate Examples Used in Documentation"},{"location":"development-guide/#building-the-library","text":"columbo is PEP 517 compliant. build is used as the frontend tool for building the library. Setuptools is used as the build backend. setup.cfg contains the library metadata. A setup.py is also included to support an editable install.","title":"Building the Library"},{"location":"development-guide/#requirements","text":"requirements.txt - Lists all direct dependencies (packages imported by the library). requirements-test.txt - Lists all direct dependencies needed for development. This primarily covers dependencies needed to run the test suite & lints.","title":"Requirements"},{"location":"development-guide/#publishing-a-new-version","text":"Once the package is ready to be released, there are a few things that need to be done: Start with a local clone of the repo on the default branch with a clean working tree. Run the version bump script with the appropriate part name ( major , minor , or patch ). Example: docker-compose run --rm bump minor This wil create a new branch, updates all affected files with the new version, and commit the changes to the branch. Push the new branch to create a new pull request. Get the pull request approved. Merge the pull request to the default branch. Merging the pull request will trigger a GitHub Action that will create a new release. The creation of this new release will trigger a GitHub Action that will to build a wheel & a source distributions of the package and push them to PyPI . Warning The action that uploads the files to PyPI will not run until a repository maintainer acknowledges that the job is ready to run. This is to keep the PyPI publishing token secure. Otherwise, any job would have access to the token. In addition to uploading the files to PyPI, the documentation website will be updated to include the new version. If the new version is a full release, it will be made the new latest version.","title":"Publishing a New Version"},{"location":"development-guide/#continuous-integration-pipeline","text":"The Continuous Integration (CI) Pipeline runs to confirm that the repository is in a good state. It will run when someone creates a pull request or when they push new commits to the branch for an existing pull request. The pipeline runs multiple different jobs that helps verify the state of the code. This same pipeline also runs on the default branch when a maintainer merges a pull request.","title":"Continuous Integration Pipeline"},{"location":"development-guide/#lints","text":"The first set of jobs that run as part of the CI pipline are linters that perform static analysis on the code. This includes: MyPy , Black , Isort , Flake8 , and Bandit .","title":"Lints"},{"location":"development-guide/#tests","text":"The next set of jobs run the unit tests using PyTest . The pipeline runs the tests cases across each supported version of Python to ensure compatibility. For each run of the test cases, the job will record the test results and code coverage information. The pipeline uploads the code coverage information to CodeCov to ensure that a pull request doesn't significantly reduce the total code coverage percentage or introduce a large amount of code that is untested.","title":"Tests"},{"location":"development-guide/#distribution-verification","text":"The next set of jobs build the wheel distribution, installs in into a virtual environment, and then runs Python to import the library version. This works as a smoke test to ensure that the library can be packaged correctly and used. The pipeline runs the tests cases across each supported version of Python to ensure compatibility.","title":"Distribution Verification"},{"location":"development-guide/#documentation","text":"The remaining jobs are all related to documentation. A job runs each of the code examples that are used in the documentation to verify they produce the expected results. A job builds the documentation in strict mode so that it will fail if there are any errors. The job records the generated files so that the documentation website can be viewed in its rendered form. When the pipeline is running as a result of a maintainer merging a pull request to the default branch, a job runs that publishes the current state of the documentation to as the dev version. This will allow users to view the state of the documentation as it has changed since a maintainer published the latest version.","title":"Documentation"},{"location":"getting-started/","text":"Getting Started Installation To install columbo , simply run this simple command in your terminal of choice: python -m pip install columbo Introduction The core of columbo are the interaction classes. They provide a way to use code to define how information should be displayed to the user and how the user should provide feedback to the running application. The most commonly used Interactions are the Questions. BasicQuestion - Print text to the terminal. Allow the user to type a text response. Pressing Enter submits the response. Choice - Print text to the terminal, followed by a numbered list of options. Allow the user to enter the number of the option they wish to select. Pressing Enter submits the response. Confirm - Print text to the terminal which expects a Yes or No answer. Pressing Y or N submits the corresponding response. In addition to those question types, there are types for when the user needs to be presented with information without providing a response. Echo - Print text to the terminal, but don't stop to accept any input from the user. Acknowledge - Print text to the terminal. Wait for the user to press Enter . After columbo has processed the questions, it returns a dictionary. More specifically the type is Dict[str, Union[str, bool]] ( columbo exposes Answers as an alias for this type). The dictionary maps question names to question answers. If the Question was Confirm , the answer will be bool . Otherwise, the answer will be str . Creating Interactions The constructors for each of these types all take a variety of arguments to configure how they should operate. The following statements cover the basic functionality: Every Interaction has a message argument that is the text that should be displayed to the user. Every Question has a name argument that is the key to be used in the Answers dictionary. Each question must have a unique name. Every Question has a default argument that is used when the user does not provide a specific value. The Usage Guide provides more detailed information about the specifics of each argument for each type of Interaction . Dynamic Values In most cases, an argument to an Interaction constructor can be dynamic (the Usage Guide details the cases where the argument can't be dynamic). A dynamic value is a function that takes the answers that have been provided this far and returns the expected value as a result. For example, message expects a string. So it also accepts a function that accepts Answers and returns a string. import columbo def dynamic_hello ( answers ): return f \"Hello, { answers [ 'name' ] } \" interactions = [ columbo . BasicQuestion ( \"name\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . Echo ( dynamic_hello ) ] columbo . get_answers ( interactions ) When iterating through these interactions, if the user replied \"Alice\" to the first question, \"Hello, Alice\" would be printed next. Walking Though Basic Examples User Prompts This is the example that appears on the main page of the documentation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" , ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions ) print ( answers ) Line 1: Import the columbo module. Line 3 - 25: Create a list of Interactions to be stored in the variable interactions . Line 4: Create an instance of Echo that will display a basic welcome message. Line 5-7: Create an instance of Acknowledge that will tell the user the program will not continue until Enter is pressed. Line 8-12: Create an instance of BasicQuestion that will ask the user to provide their name. The key user will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of Patrick will be used. Line 13-17: Create an instance of BasicQuestion that will ask the user to provide their email address. The displayed message is dynamic and will include the value from the previous question. The key user_email will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of me@example.com will be used. Line 18-23: Create an instance of Choice that will ask the user for their current mood. The question allows the user to select one of four options. The key mood will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of happy will be used. Line 24: Create an instance of Confirm that will ask the user if they like dogs. The key likes_dogs will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of True will be used. Line 27: Have columbo iterate over the Interactions prompting the user for each question. Line 28: Print tha Answers dictionary so that the values can be seen. Command Line Arguments This is the example will be just like the previous example , except it will demonstrate the Command Line functionality. The relevant change can be seen here: 24 25 26 27 28 29 30 31 columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . parse_args ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-dogs\" , ]) print ( answers ) The full example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" , ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . parse_args ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-dogs\" , ], ) print ( answers ) Line 27-30: Have columbo iterate over the Interactions parsing the given command line arguments. Line 28: Provide the value of patrick@example.com for the question requesting the user's email address. Line 29: Select the value of True for the question asking the user if they like dogs. Note If you omit the args parameter to parse_args() the values in sys.argv will be used. What's Next? Read the Usage Guide for a more detailed descriptions of ways you can use columbo . Read the API Reference for specific information about all the functions and classes made available by columbo .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"To install columbo , simply run this simple command in your terminal of choice: python -m pip install columbo","title":"Installation"},{"location":"getting-started/#introduction","text":"The core of columbo are the interaction classes. They provide a way to use code to define how information should be displayed to the user and how the user should provide feedback to the running application. The most commonly used Interactions are the Questions. BasicQuestion - Print text to the terminal. Allow the user to type a text response. Pressing Enter submits the response. Choice - Print text to the terminal, followed by a numbered list of options. Allow the user to enter the number of the option they wish to select. Pressing Enter submits the response. Confirm - Print text to the terminal which expects a Yes or No answer. Pressing Y or N submits the corresponding response. In addition to those question types, there are types for when the user needs to be presented with information without providing a response. Echo - Print text to the terminal, but don't stop to accept any input from the user. Acknowledge - Print text to the terminal. Wait for the user to press Enter . After columbo has processed the questions, it returns a dictionary. More specifically the type is Dict[str, Union[str, bool]] ( columbo exposes Answers as an alias for this type). The dictionary maps question names to question answers. If the Question was Confirm , the answer will be bool . Otherwise, the answer will be str .","title":"Introduction"},{"location":"getting-started/#creating-interactions","text":"The constructors for each of these types all take a variety of arguments to configure how they should operate. The following statements cover the basic functionality: Every Interaction has a message argument that is the text that should be displayed to the user. Every Question has a name argument that is the key to be used in the Answers dictionary. Each question must have a unique name. Every Question has a default argument that is used when the user does not provide a specific value. The Usage Guide provides more detailed information about the specifics of each argument for each type of Interaction .","title":"Creating Interactions"},{"location":"getting-started/#dynamic-values","text":"In most cases, an argument to an Interaction constructor can be dynamic (the Usage Guide details the cases where the argument can't be dynamic). A dynamic value is a function that takes the answers that have been provided this far and returns the expected value as a result. For example, message expects a string. So it also accepts a function that accepts Answers and returns a string. import columbo def dynamic_hello ( answers ): return f \"Hello, { answers [ 'name' ] } \" interactions = [ columbo . BasicQuestion ( \"name\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . Echo ( dynamic_hello ) ] columbo . get_answers ( interactions ) When iterating through these interactions, if the user replied \"Alice\" to the first question, \"Hello, Alice\" would be printed next.","title":"Dynamic Values"},{"location":"getting-started/#walking-though-basic-examples","text":"","title":"Walking Though Basic Examples"},{"location":"getting-started/#user-prompts","text":"This is the example that appears on the main page of the documentation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" , ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions ) print ( answers ) Line 1: Import the columbo module. Line 3 - 25: Create a list of Interactions to be stored in the variable interactions . Line 4: Create an instance of Echo that will display a basic welcome message. Line 5-7: Create an instance of Acknowledge that will tell the user the program will not continue until Enter is pressed. Line 8-12: Create an instance of BasicQuestion that will ask the user to provide their name. The key user will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of Patrick will be used. Line 13-17: Create an instance of BasicQuestion that will ask the user to provide their email address. The displayed message is dynamic and will include the value from the previous question. The key user_email will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of me@example.com will be used. Line 18-23: Create an instance of Choice that will ask the user for their current mood. The question allows the user to select one of four options. The key mood will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of happy will be used. Line 24: Create an instance of Confirm that will ask the user if they like dogs. The key likes_dogs will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of True will be used. Line 27: Have columbo iterate over the Interactions prompting the user for each question. Line 28: Print tha Answers dictionary so that the values can be seen.","title":"User Prompts"},{"location":"getting-started/#command-line-arguments","text":"This is the example will be just like the previous example , except it will demonstrate the Command Line functionality. The relevant change can be seen here: 24 25 26 27 28 29 30 31 columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . parse_args ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-dogs\" , ]) print ( answers ) The full example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" , ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . parse_args ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-dogs\" , ], ) print ( answers ) Line 27-30: Have columbo iterate over the Interactions parsing the given command line arguments. Line 28: Provide the value of patrick@example.com for the question requesting the user's email address. Line 29: Select the value of True for the question asking the user if they like dogs. Note If you omit the args parameter to parse_args() the values in sys.argv will be used.","title":"Command Line Arguments"},{"location":"getting-started/#whats-next","text":"Read the Usage Guide for a more detailed descriptions of ways you can use columbo . Read the API Reference for specific information about all the functions and classes made available by columbo .","title":"What's Next?"},{"location":"why-columbo/","text":"Why Columbo? columbo started as an internal library used at Wayfair by the Python Platforms team. It is now an open source project with the hope that it will provide benefit from the greater Python community. What problem did Columbo initially solve? One of the primary resources the Python Platforms team provides to Wayfair engineers is a set of project templates. This allows an engineering team to hit the ground running when starting when needing to start a new HTTP application or Python package. That templates contain best-practice patterns and allow developers to initialize and deploy a new application to production in minutes. The project templates use Cookiecutter in order to generate the files that will be used in the new project. While Cookiecutter makes many things easy for maintainers of a template, the terminal user interface it provides has a few issues: The text Cookiecutter presents to the user is also the name used to access the value within the template. This can make it hard for a user to know exactly what information the template is asking for. Cookiecutter always prompts the user for a value for every item defined by the template. Our templates have optional features that need additional information when used. When a user chooses not to use a given feature, they are still prompted to provide a value for the items that will not be used when generating files. Cookiecutter does not support validating given values when the user prompting the user to provide input. If a template requires the value for the first item to be a number, the user will be prompted for values for the remaining items. When the validation error occurs, the user always needs to start again from scratch. Cookiecutter can be executed programmatically by passing in a dictionary of values. This allows columbo to handle the user prompts resolving the issues we experienced, while still using Cookiecutter under the covers. With this pattern, all project templates managed by language platform teams at Wayfair benefit from the user experience of working with Cookiecutter templates. Alternatives columbo is not the only library that exists which provides a way to codify prompting a user for answers to a set of questions. This section compares columbo with some libraries which were created to achieve this task. PyInquirer PyInquirer was a major inspiration in the development of columbo . PyInquirer supports optional questions and validation in similar way to how columbo supports those features. PyInquirer has some features that columbo does not. It has some additional interaction types like selecting multiple options from a list and using an external editor to provide a long form response. It also exposes more rendering options of prompt-toolkit , which is used internally by both libraries. columbo has some features that PyInquirer does not. PyInquirer does not support dynamic values as arguments used to construct a question. Additionally, PyInquirer does not provide an option to parse command line arguments as answers to a set of questions. The primary reason why we chose to create columbo instead of using PyInquirer was that the project was still using version 1 of prompt-toolkit while the maintainers of that library were preparing to release version 3 1 . Additionally, the library uses an un-typed dictionary to describe each question, which can make it easier to make configuration mistakes. python-inquirer python-inquirer is similar to columbo in that they both support dynamic values, validation and optional questions. They also both use classes to represent interactions. python-inquirer has some features that columbo does not. It has some additional interaction types like selecting multiple options from a list and using an external editor to provide a long form response. It also exposes more rendering options of blessed . columbo has some features that python-inquirer does not. python-inquirer does not provide an option to parse command line arguments as answers to a set of questions or have interactions that do not store an answer. Additionally, colombo 's API is fully type annotated, while python-inquirer 's API is not. questionary questionary is similar to columbo in that they both support validation, optional questions, and use classes to represent interactions 2 . The API's for both libraries are fully type annotated. questionary has some features that columbo does not. It has some additional interaction types like supporting tab completion for some answers. It also exposes more rendering options of prompt-toolkit , which is used internally by both libraries. questionary can also ask questions asynchronously. columbo has some features that questionary does not. questionary does not support dynamic values as arguments used to construct a question or provide an option to parse command line arguments as answers to a set of questions. At the time of writing this document (February 2021), the PyInquirer repo has been updated to use version 3 of prompt-toolkit, but a new release has not been published to PyPi. \u21a9 Dynamic optional questions requires questions to be specified using a dictionary instead of the class representation. \u21a9","title":"Why Columbo?"},{"location":"why-columbo/#why-columbo","text":"columbo started as an internal library used at Wayfair by the Python Platforms team. It is now an open source project with the hope that it will provide benefit from the greater Python community.","title":"Why Columbo?"},{"location":"why-columbo/#what-problem-did-columbo-initially-solve","text":"One of the primary resources the Python Platforms team provides to Wayfair engineers is a set of project templates. This allows an engineering team to hit the ground running when starting when needing to start a new HTTP application or Python package. That templates contain best-practice patterns and allow developers to initialize and deploy a new application to production in minutes. The project templates use Cookiecutter in order to generate the files that will be used in the new project. While Cookiecutter makes many things easy for maintainers of a template, the terminal user interface it provides has a few issues: The text Cookiecutter presents to the user is also the name used to access the value within the template. This can make it hard for a user to know exactly what information the template is asking for. Cookiecutter always prompts the user for a value for every item defined by the template. Our templates have optional features that need additional information when used. When a user chooses not to use a given feature, they are still prompted to provide a value for the items that will not be used when generating files. Cookiecutter does not support validating given values when the user prompting the user to provide input. If a template requires the value for the first item to be a number, the user will be prompted for values for the remaining items. When the validation error occurs, the user always needs to start again from scratch. Cookiecutter can be executed programmatically by passing in a dictionary of values. This allows columbo to handle the user prompts resolving the issues we experienced, while still using Cookiecutter under the covers. With this pattern, all project templates managed by language platform teams at Wayfair benefit from the user experience of working with Cookiecutter templates.","title":"What problem did Columbo initially solve?"},{"location":"why-columbo/#alternatives","text":"columbo is not the only library that exists which provides a way to codify prompting a user for answers to a set of questions. This section compares columbo with some libraries which were created to achieve this task.","title":"Alternatives"},{"location":"why-columbo/#pyinquirer","text":"PyInquirer was a major inspiration in the development of columbo . PyInquirer supports optional questions and validation in similar way to how columbo supports those features. PyInquirer has some features that columbo does not. It has some additional interaction types like selecting multiple options from a list and using an external editor to provide a long form response. It also exposes more rendering options of prompt-toolkit , which is used internally by both libraries. columbo has some features that PyInquirer does not. PyInquirer does not support dynamic values as arguments used to construct a question. Additionally, PyInquirer does not provide an option to parse command line arguments as answers to a set of questions. The primary reason why we chose to create columbo instead of using PyInquirer was that the project was still using version 1 of prompt-toolkit while the maintainers of that library were preparing to release version 3 1 . Additionally, the library uses an un-typed dictionary to describe each question, which can make it easier to make configuration mistakes.","title":"PyInquirer"},{"location":"why-columbo/#python-inquirer","text":"python-inquirer is similar to columbo in that they both support dynamic values, validation and optional questions. They also both use classes to represent interactions. python-inquirer has some features that columbo does not. It has some additional interaction types like selecting multiple options from a list and using an external editor to provide a long form response. It also exposes more rendering options of blessed . columbo has some features that python-inquirer does not. python-inquirer does not provide an option to parse command line arguments as answers to a set of questions or have interactions that do not store an answer. Additionally, colombo 's API is fully type annotated, while python-inquirer 's API is not.","title":"python-inquirer"},{"location":"why-columbo/#questionary","text":"questionary is similar to columbo in that they both support validation, optional questions, and use classes to represent interactions 2 . The API's for both libraries are fully type annotated. questionary has some features that columbo does not. It has some additional interaction types like supporting tab completion for some answers. It also exposes more rendering options of prompt-toolkit , which is used internally by both libraries. questionary can also ask questions asynchronously. columbo has some features that questionary does not. questionary does not support dynamic values as arguments used to construct a question or provide an option to parse command line arguments as answers to a set of questions. At the time of writing this document (February 2021), the PyInquirer repo has been updated to use version 3 of prompt-toolkit, but a new release has not been published to PyPi. \u21a9 Dynamic optional questions requires questions to be specified using a dictionary instead of the class representation. \u21a9","title":"questionary"},{"location":"examples/","text":"Examples These are the examples used in the documentation .","title":"Examples"},{"location":"examples/#examples","text":"These are the examples used in the documentation .","title":"Examples"},{"location":"usage-guide/command-line/","text":"Command Line Interface In addition to providing an interactive terminal based UI to ask the user each question, columbo can also generate a command line argument parser based on the list of Interaction s. When used in this manner, Echo & Acknowledge are ignored. To produce a consistent command line argument format, columbo will do the following to the value of each question's name : Make it lowercase. Replace space characters with dashes Replace underscore character with dash For example: Original Result user user user_email user-email User Email user-email Warning As a result of the transformation process, it is possible to have a sequence of questions with unique name s for the Answers dictionary, but cause a collision when creating command line arguments. For BasicQuestion & Choice , the result will be preceded with two dashes (ex: --user or --user-email ). For Confirm , columbo produces two command lines arguments. After following the transformation rules, the command line arguments will be --{NAME} & --no-{NAME} to explicitly specify True or False , respectively (ex: --likes-dogs and --no-likes-dogs ) Since the argument parser must be constructed before receiving any user input, all Question s produce arguments. should_ask is only considered when processing the given arguments.","title":"Command Line Interface"},{"location":"usage-guide/command-line/#command-line-interface","text":"In addition to providing an interactive terminal based UI to ask the user each question, columbo can also generate a command line argument parser based on the list of Interaction s. When used in this manner, Echo & Acknowledge are ignored. To produce a consistent command line argument format, columbo will do the following to the value of each question's name : Make it lowercase. Replace space characters with dashes Replace underscore character with dash For example: Original Result user user user_email user-email User Email user-email Warning As a result of the transformation process, it is possible to have a sequence of questions with unique name s for the Answers dictionary, but cause a collision when creating command line arguments. For BasicQuestion & Choice , the result will be preceded with two dashes (ex: --user or --user-email ). For Confirm , columbo produces two command lines arguments. After following the transformation rules, the command line arguments will be --{NAME} & --no-{NAME} to explicitly specify True or False , respectively (ex: --likes-dogs and --no-likes-dogs ) Since the argument parser must be constructed before receiving any user input, all Question s produce arguments. should_ask is only considered when processing the given arguments.","title":"Command Line Interface"},{"location":"usage-guide/fundamentals/","text":"Usage Guide This section provides detailed descriptions of all the ways columbo can be used. If you are new to columbo , the Getting Started page provides a gradual introduction of the basic functionality with examples. Static vs Dynamic Values Before diving into the specifics about each Interaction type, it is important to understand how columbo supports both static and dynamic values. A static value is a value that is known when creating an Interaction instance. Frequently this will be a value like a string literal, but that is not a requirement. In contrast, a dynamic value is one which depends on one or more answer provided by the user from a previous question. This is supported by accepting a function that takes an Answers dictionary as an argument and returns a value with the type of that static value would have. For example, the static value for message is str . Therefore, the dynamic value would be a function that accepts Answers and returns a string ( Callable[[Answers],str] ). In most cases, any argument to an Interaction 's constructor can be dynamic. This guide will explicitly mention when the constructor requires an argument to be a static value. Detailed Sections Interactions Optional Questions & Branching Validators Command Line Interface","title":"Fundamentals"},{"location":"usage-guide/fundamentals/#usage-guide","text":"This section provides detailed descriptions of all the ways columbo can be used. If you are new to columbo , the Getting Started page provides a gradual introduction of the basic functionality with examples.","title":"Usage Guide"},{"location":"usage-guide/fundamentals/#static-vs-dynamic-values","text":"Before diving into the specifics about each Interaction type, it is important to understand how columbo supports both static and dynamic values. A static value is a value that is known when creating an Interaction instance. Frequently this will be a value like a string literal, but that is not a requirement. In contrast, a dynamic value is one which depends on one or more answer provided by the user from a previous question. This is supported by accepting a function that takes an Answers dictionary as an argument and returns a value with the type of that static value would have. For example, the static value for message is str . Therefore, the dynamic value would be a function that accepts Answers and returns a string ( Callable[[Answers],str] ). In most cases, any argument to an Interaction 's constructor can be dynamic. This guide will explicitly mention when the constructor requires an argument to be a static value.","title":"Static vs Dynamic Values"},{"location":"usage-guide/fundamentals/#detailed-sections","text":"Interactions Optional Questions & Branching Validators Command Line Interface","title":"Detailed Sections"},{"location":"usage-guide/interactions/","text":"Interactions columbo provides five types of Interactions that can be used to control how the program will interact with the user: Echo - Print text to the terminal, but don't stop to accept any input from the user. Acknowledge - Print text to the terminal. Wait for the user to press Enter . BasicQuestion - Print text to the terminal. Allow the user to type a text response. Pressing Enter submits the response. Choice - Print text to the terminal, followed by a numbered list of options. Allow the user to enter the number of the option they wish to select. Pressing Enter submits the response. Confirm - Print text to the terminal which expects a Yes or No answer. Pressing Y or N submits the corresponding response. Creating Interactions Echo & Acknowledge Echo and Acknowledge both accept message as their only argument. This is the message to be displayed to the user. All Questions BasicQuestion , Choice , & Confirm all accept the following arguments. name : The identifier that will be used as the key to access this question's answer. Each question must have a unique value for name . Can't be dynamic . message : The message to be displayed to the user. default : The default answer to the question. This is used when the user does not provide an explicit value. should_ask : Optional. When given, the argument should be a function that accepts an Answers dictionary and returns True or False . Returning True indicates that the question should be asked. Returning False will skip the question and not present it to the user. See Optional Questions & Branching for more details. cli_help : Optional. A help message to be displayed for command line interface. See CLI documentation for more details. Can't be dynamic . value_if_not_asked : Optional. A value used as an answer if the question is not asked. Can't be dynamic . Basic Question In addition to the arguments mentioned above , BasicQuestion also accepts the following argument. validator : Optional. When given, the argument should be a function that checks if the user response is valid. Not providing this argument means that any value provided by the user will be accepted. See Validators for more details. Choice In addition to the arguments mentioned above , Choice also accepts the following argument. options : The list of possible value the user can choose from. Confirm Confirm doesn't take any additional arguments that weren't mentioned above . However, the default argument takes a bool instead of str and defaults to False .","title":"Interactions"},{"location":"usage-guide/interactions/#interactions","text":"columbo provides five types of Interactions that can be used to control how the program will interact with the user: Echo - Print text to the terminal, but don't stop to accept any input from the user. Acknowledge - Print text to the terminal. Wait for the user to press Enter . BasicQuestion - Print text to the terminal. Allow the user to type a text response. Pressing Enter submits the response. Choice - Print text to the terminal, followed by a numbered list of options. Allow the user to enter the number of the option they wish to select. Pressing Enter submits the response. Confirm - Print text to the terminal which expects a Yes or No answer. Pressing Y or N submits the corresponding response.","title":"Interactions"},{"location":"usage-guide/interactions/#creating-interactions","text":"","title":"Creating Interactions"},{"location":"usage-guide/interactions/#echo-acknowledge","text":"Echo and Acknowledge both accept message as their only argument. This is the message to be displayed to the user.","title":"Echo &amp; Acknowledge"},{"location":"usage-guide/interactions/#all-questions","text":"BasicQuestion , Choice , & Confirm all accept the following arguments. name : The identifier that will be used as the key to access this question's answer. Each question must have a unique value for name . Can't be dynamic . message : The message to be displayed to the user. default : The default answer to the question. This is used when the user does not provide an explicit value. should_ask : Optional. When given, the argument should be a function that accepts an Answers dictionary and returns True or False . Returning True indicates that the question should be asked. Returning False will skip the question and not present it to the user. See Optional Questions & Branching for more details. cli_help : Optional. A help message to be displayed for command line interface. See CLI documentation for more details. Can't be dynamic . value_if_not_asked : Optional. A value used as an answer if the question is not asked. Can't be dynamic .","title":"All Questions"},{"location":"usage-guide/interactions/#basic-question","text":"In addition to the arguments mentioned above , BasicQuestion also accepts the following argument. validator : Optional. When given, the argument should be a function that checks if the user response is valid. Not providing this argument means that any value provided by the user will be accepted. See Validators for more details.","title":"Basic Question"},{"location":"usage-guide/interactions/#choice","text":"In addition to the arguments mentioned above , Choice also accepts the following argument. options : The list of possible value the user can choose from.","title":"Choice"},{"location":"usage-guide/interactions/#confirm","text":"Confirm doesn't take any additional arguments that weren't mentioned above . However, the default argument takes a bool instead of str and defaults to False .","title":"Confirm"},{"location":"usage-guide/optional-questions-and-branching/","text":"Only Asking Some Questions There are situations where a question should be asked some times, but not all the time. For example, a program that collects information about a user's pets should not ask the user for the dog's name and breed if the user said they do not have a dog. The should_ask argument that is present on each question provides a way to achieve this functionality. Similarly, should_ask can be used to provide branching paths to the user. An example of these branching paths is a Choose Your Own Adventure story. The story provides the reader with choices during the adventure. These choices introduce diverging paths of interactions that may or may not join at the end. Warning By default when columbo skips over a question, the Answers dictionary will NOT contain a key-value pair for the skipped question. If you want a skipped question to have a specific answer when skipped, you can do so using the value_if_not_asked kwarg as detailed in the section below. Optional Questions The following is a basic example that has two optional questions that are not asked based on the answer to the first question. import columbo def user_has_dog ( answers : columbo . Answers ) -> bool : return answers [ \"has_dog\" ] interactions = [ columbo . Confirm ( \"has_dog\" , \"Do you have a dog?\" , default = True ), columbo . BasicQuestion ( \"dog_name\" , \"What is the name of the dog?\" , should_ask = user_has_dog , default = \"Kaylee\" , ), columbo . BasicQuestion ( \"dog_breed\" , \"What is the breed of the dog?\" , should_ask = user_has_dog , default = \"Basset Hound\" , ), ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) If the user accepts the default answers for each of these questions, the output will be: { \"has_dog\" : True , \"dog_name\" : \"Kaylee\" , \"dog_breed\" : \"Basset Hound\" } However, when the user answers the first question with \"no\", the output will be: { \"has_dog\" : False } Note that the Answers dictionary in the previous example has an answer to only the first question (there are no answers for the skipped questions). The next section shows how to provide an answer for a skipped question. Providing an Answer for Skipped Questions To provide a specific answer used when a user skips a question, use the value_if_not_asked kwarg: import columbo def user_has_dog ( answers : columbo . Answers ) -> bool : return answers [ \"has_dog\" ] interactions = [ columbo . Confirm ( \"has_dog\" , \"Do you have a dog?\" , default = True ), columbo . BasicQuestion ( \"dog_name\" , \"What is the name of the dog?\" , should_ask = user_has_dog , value_if_not_asked = \"n/a\" , default = \"Kaylee\" , ), columbo . BasicQuestion ( \"dog_breed\" , \"What is the breed of the dog?\" , should_ask = user_has_dog , value_if_not_asked = \"n/a\" , default = \"Basset Hound\" , ), ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) If the user answers the first question with \"no\", the output will now be: { \"has_dog\" : False , \"dog_name\" : \"n/a\" , \"dog_breed\" : \"n/a\" } Columbo will not ask the user for a dog name or breed, but the answers will have the values provided with the value_if_not_asked kwarg. Branching Paths A question that is part of a branching path is very similar to an optional question. It is still a question where the should_ask function was provided to determine if the question should be skipped or not. The branching aspect comes from there being at least two sets of optional questions. Each set has a should_ask argument that checks for a different state for a single answer. In this way, only one of the sets of optional questions will ever be asked. The following is an example of a short story that has two divergent paths that join at the end. Each individual question isn't different from the optional questions demonstrated above . The program achieves the branching paths by supplying different should_ask values that will never both evaluate to True . import columbo def went_left ( answers : columbo . Answers ) -> bool : return answers [ \"which_door\" ] == \"left\" def went_right ( answers : columbo . Answers ) -> bool : return answers [ \"which_door\" ] == \"right\" def outcome ( answers : columbo . Answers ) -> str : if answers . get ( \"has_key\" , False ): return \"You try the the key on the lock. With a little jiggling, it finally opens. You open the gate and leave.\" if answers . get ( \"has_hammer\" , False ): return \"You hit the lock with the hammer and it falls to the ground. You open the gate and leave.\" return ( \"Unable to open the gate yourself, you yell for help. A farmer in the nearby field hears you. \" \"He reaches into his pocket and pulls out a key to unlock the gate and open it. \" \"As you walk through the archway he says, \" '\"What I don \\' t understand is how you got in there. This is the only key.\"' ) interactions = [ columbo . Echo ( \"You wake up in a room that you do not recognize. \" \"In the dim light, you can see a large door to the left and a small door to the right.\" ), columbo . Choice ( \"which_door\" , \"Which door do you walk through?\" , options = [ \"left\" , \"right\" ], default = \"left\" , ), columbo . Confirm ( \"has_key\" , \"You step into a short hallway and the door closes behind you, refusing to open again. \" \"As you walk down the hallway, there is a small side table with a key on it. \\n \" \"Do you pick up the key before going through the door at the other end?\" , should_ask = went_left , default = True , ), columbo . Confirm ( \"has_hammer\" , \"You step into smaller room and the door closes behind, refusing to open again. \" \"The room has a single door on the opposite side of the room and a work bench with a hammer on it. \\n \" \"Do you pick up the hammer before going through the door at the other side?\" , should_ask = went_right , default = True , ), columbo . Echo ( \"You enter a small courtyard with high walls. There is an archway that would allow you to go free, \" \"but the gate is locked.\" ), columbo . Echo ( outcome ), ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) The import thing to note in the example above is that the Answers dictionary can have a key-value pair for has_key or has_hammer , not both.","title":"Optional Questions & Branching"},{"location":"usage-guide/optional-questions-and-branching/#only-asking-some-questions","text":"There are situations where a question should be asked some times, but not all the time. For example, a program that collects information about a user's pets should not ask the user for the dog's name and breed if the user said they do not have a dog. The should_ask argument that is present on each question provides a way to achieve this functionality. Similarly, should_ask can be used to provide branching paths to the user. An example of these branching paths is a Choose Your Own Adventure story. The story provides the reader with choices during the adventure. These choices introduce diverging paths of interactions that may or may not join at the end. Warning By default when columbo skips over a question, the Answers dictionary will NOT contain a key-value pair for the skipped question. If you want a skipped question to have a specific answer when skipped, you can do so using the value_if_not_asked kwarg as detailed in the section below.","title":"Only Asking Some Questions"},{"location":"usage-guide/optional-questions-and-branching/#optional-questions","text":"The following is a basic example that has two optional questions that are not asked based on the answer to the first question. import columbo def user_has_dog ( answers : columbo . Answers ) -> bool : return answers [ \"has_dog\" ] interactions = [ columbo . Confirm ( \"has_dog\" , \"Do you have a dog?\" , default = True ), columbo . BasicQuestion ( \"dog_name\" , \"What is the name of the dog?\" , should_ask = user_has_dog , default = \"Kaylee\" , ), columbo . BasicQuestion ( \"dog_breed\" , \"What is the breed of the dog?\" , should_ask = user_has_dog , default = \"Basset Hound\" , ), ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) If the user accepts the default answers for each of these questions, the output will be: { \"has_dog\" : True , \"dog_name\" : \"Kaylee\" , \"dog_breed\" : \"Basset Hound\" } However, when the user answers the first question with \"no\", the output will be: { \"has_dog\" : False } Note that the Answers dictionary in the previous example has an answer to only the first question (there are no answers for the skipped questions). The next section shows how to provide an answer for a skipped question.","title":"Optional Questions"},{"location":"usage-guide/optional-questions-and-branching/#providing-an-answer-for-skipped-questions","text":"To provide a specific answer used when a user skips a question, use the value_if_not_asked kwarg: import columbo def user_has_dog ( answers : columbo . Answers ) -> bool : return answers [ \"has_dog\" ] interactions = [ columbo . Confirm ( \"has_dog\" , \"Do you have a dog?\" , default = True ), columbo . BasicQuestion ( \"dog_name\" , \"What is the name of the dog?\" , should_ask = user_has_dog , value_if_not_asked = \"n/a\" , default = \"Kaylee\" , ), columbo . BasicQuestion ( \"dog_breed\" , \"What is the breed of the dog?\" , should_ask = user_has_dog , value_if_not_asked = \"n/a\" , default = \"Basset Hound\" , ), ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) If the user answers the first question with \"no\", the output will now be: { \"has_dog\" : False , \"dog_name\" : \"n/a\" , \"dog_breed\" : \"n/a\" } Columbo will not ask the user for a dog name or breed, but the answers will have the values provided with the value_if_not_asked kwarg.","title":"Providing an Answer for Skipped Questions"},{"location":"usage-guide/optional-questions-and-branching/#branching-paths","text":"A question that is part of a branching path is very similar to an optional question. It is still a question where the should_ask function was provided to determine if the question should be skipped or not. The branching aspect comes from there being at least two sets of optional questions. Each set has a should_ask argument that checks for a different state for a single answer. In this way, only one of the sets of optional questions will ever be asked. The following is an example of a short story that has two divergent paths that join at the end. Each individual question isn't different from the optional questions demonstrated above . The program achieves the branching paths by supplying different should_ask values that will never both evaluate to True . import columbo def went_left ( answers : columbo . Answers ) -> bool : return answers [ \"which_door\" ] == \"left\" def went_right ( answers : columbo . Answers ) -> bool : return answers [ \"which_door\" ] == \"right\" def outcome ( answers : columbo . Answers ) -> str : if answers . get ( \"has_key\" , False ): return \"You try the the key on the lock. With a little jiggling, it finally opens. You open the gate and leave.\" if answers . get ( \"has_hammer\" , False ): return \"You hit the lock with the hammer and it falls to the ground. You open the gate and leave.\" return ( \"Unable to open the gate yourself, you yell for help. A farmer in the nearby field hears you. \" \"He reaches into his pocket and pulls out a key to unlock the gate and open it. \" \"As you walk through the archway he says, \" '\"What I don \\' t understand is how you got in there. This is the only key.\"' ) interactions = [ columbo . Echo ( \"You wake up in a room that you do not recognize. \" \"In the dim light, you can see a large door to the left and a small door to the right.\" ), columbo . Choice ( \"which_door\" , \"Which door do you walk through?\" , options = [ \"left\" , \"right\" ], default = \"left\" , ), columbo . Confirm ( \"has_key\" , \"You step into a short hallway and the door closes behind you, refusing to open again. \" \"As you walk down the hallway, there is a small side table with a key on it. \\n \" \"Do you pick up the key before going through the door at the other end?\" , should_ask = went_left , default = True , ), columbo . Confirm ( \"has_hammer\" , \"You step into smaller room and the door closes behind, refusing to open again. \" \"The room has a single door on the opposite side of the room and a work bench with a hammer on it. \\n \" \"Do you pick up the hammer before going through the door at the other side?\" , should_ask = went_right , default = True , ), columbo . Echo ( \"You enter a small courtyard with high walls. There is an archway that would allow you to go free, \" \"but the gate is locked.\" ), columbo . Echo ( outcome ), ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) The import thing to note in the example above is that the Answers dictionary can have a key-value pair for has_key or has_hammer , not both.","title":"Branching Paths"},{"location":"usage-guide/validators/","text":"Validators Context BasicQuestion allows the user to provide arbitrary text as the answer to the question. However, there are frequently constraints on what is considered a valid answer. Providing a Validator for the question allows columbo to verify that the text provided by the user satisfies those constraints. If the answer is not valid, columbo will tell the user that the answer is not valid and ask them to try again. Note While Choice and Confirm do not expose a validator argument they still ensure that the answer is valid. A Confirm question will only continue when Y , N , or Enter are pressed. Any other keys will be ignored. A Choice question will only continue when Enter is pressed if the input matches the number columbo assigned to one of the choices. Validator Structure A Validator must be a function which has the following type signature: Callable[[str, Answers], ValidationResponse] 1 . We'll walk through this signature explaining each part. A Validator takes two arguments: a string (which is the response provided by the user to a question) and an Answers dictionary containing the answer for each previous question. The Validator must return a ValidationResponse which is a type alias for: Union[ValidationFailure, ValidationSuccess] 1 . Thus, a Validator must return either a ValidationFailure or a ValidationSuccess object. You should use a ValidationSuccess when the user's response is valid and ValidationFailure when the user's response is invalid. Both ValidationFailure and ValidationSuccess have a valid attribute that is False and True , respectively. A ValidationFailure requires that you provide an error which describes why the given value was invalid ( columbo will display this message before asking users to answer the question again so users get some feedback about what they are doing wrong). Upgrading Validator Structure Validators could return Optional[str] before < 0.10.0 , this was removed in 1.0.0 . The docs in this section detail how to upgrade a Validator from a columbo version < 0.10.0 to the newer Validator structure. Feel free to skip this section if it's not pertinent to you. Previously, a Validator would return either an error message (as a string) if validation failed or None if the validation succeeded. To update a Validator , you should update the validator function to return ValidationFailure if validation fails and ValidationSuccess if the validation succeeds. The table below describes the old and new return values for different validation statuses. Validation Status Old Return Value (before 0.10.0 ) New Return Value (since 0.10.0 ) Failed \"Some error message\" ValidationFailure(error=\"Some error message\") Succeeded None ValidationSuccess() Example Validator Let's say we were asking for a user's email address. The Validator below provides a simple check to see if the email address seems valid 1 . If the user's response doesn't contain an @ character with at least one word character on each side then the response is invalid and the user will have to enter an email address again (hopefully a valid one this time). import re from typing import List import columbo def is_email_address ( value : str , _ : columbo . Answers ) -> columbo . ValidationResponse : if not re . match ( r \"^\\w+@\\w+\" , value ): error_message = f \" { value } is not a valid email address\" return columbo . ValidationFailure ( error = error_message ) return columbo . ValidationSuccess () interactions : List [ columbo . Interaction ] = [ columbo . BasicQuestion ( \"user_email_address\" , \"What email address should be used to contact you?\" , default = \"me@example.com\" , validator = is_email_address , ) ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) The regular expression for checking for an RFC 822 compliant email address is overly complicated . Additionally, that only ensures that the text is valid. It does not confirm if the host will accept emails sent to that address or if the user is the owner of the email address. \u21a9 \u21a9 \u21a9","title":"Validators"},{"location":"usage-guide/validators/#validators","text":"","title":"Validators"},{"location":"usage-guide/validators/#context","text":"BasicQuestion allows the user to provide arbitrary text as the answer to the question. However, there are frequently constraints on what is considered a valid answer. Providing a Validator for the question allows columbo to verify that the text provided by the user satisfies those constraints. If the answer is not valid, columbo will tell the user that the answer is not valid and ask them to try again. Note While Choice and Confirm do not expose a validator argument they still ensure that the answer is valid. A Confirm question will only continue when Y , N , or Enter are pressed. Any other keys will be ignored. A Choice question will only continue when Enter is pressed if the input matches the number columbo assigned to one of the choices.","title":"Context"},{"location":"usage-guide/validators/#validator-structure","text":"A Validator must be a function which has the following type signature: Callable[[str, Answers], ValidationResponse] 1 . We'll walk through this signature explaining each part. A Validator takes two arguments: a string (which is the response provided by the user to a question) and an Answers dictionary containing the answer for each previous question. The Validator must return a ValidationResponse which is a type alias for: Union[ValidationFailure, ValidationSuccess] 1 . Thus, a Validator must return either a ValidationFailure or a ValidationSuccess object. You should use a ValidationSuccess when the user's response is valid and ValidationFailure when the user's response is invalid. Both ValidationFailure and ValidationSuccess have a valid attribute that is False and True , respectively. A ValidationFailure requires that you provide an error which describes why the given value was invalid ( columbo will display this message before asking users to answer the question again so users get some feedback about what they are doing wrong).","title":"Validator Structure"},{"location":"usage-guide/validators/#upgrading-validator-structure","text":"Validators could return Optional[str] before < 0.10.0 , this was removed in 1.0.0 . The docs in this section detail how to upgrade a Validator from a columbo version < 0.10.0 to the newer Validator structure. Feel free to skip this section if it's not pertinent to you. Previously, a Validator would return either an error message (as a string) if validation failed or None if the validation succeeded. To update a Validator , you should update the validator function to return ValidationFailure if validation fails and ValidationSuccess if the validation succeeds. The table below describes the old and new return values for different validation statuses. Validation Status Old Return Value (before 0.10.0 ) New Return Value (since 0.10.0 ) Failed \"Some error message\" ValidationFailure(error=\"Some error message\") Succeeded None ValidationSuccess()","title":"Upgrading Validator Structure"},{"location":"usage-guide/validators/#example-validator","text":"Let's say we were asking for a user's email address. The Validator below provides a simple check to see if the email address seems valid 1 . If the user's response doesn't contain an @ character with at least one word character on each side then the response is invalid and the user will have to enter an email address again (hopefully a valid one this time). import re from typing import List import columbo def is_email_address ( value : str , _ : columbo . Answers ) -> columbo . ValidationResponse : if not re . match ( r \"^\\w+@\\w+\" , value ): error_message = f \" { value } is not a valid email address\" return columbo . ValidationFailure ( error = error_message ) return columbo . ValidationSuccess () interactions : List [ columbo . Interaction ] = [ columbo . BasicQuestion ( \"user_email_address\" , \"What email address should be used to contact you?\" , default = \"me@example.com\" , validator = is_email_address , ) ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) The regular expression for checking for an RFC 822 compliant email address is overly complicated . Additionally, that only ensures that the text is valid. It does not confirm if the host will accept emails sent to that address or if the user is the owner of the email address. \u21a9 \u21a9 \u21a9","title":"Example Validator"}]}